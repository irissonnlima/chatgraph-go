// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.20.3
// source: router.proto

package chatbot

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	UserStateService_InsertUpdateUserState_FullMethodName = "/chatbot.UserStateService/InsertUpdateUserState"
	UserStateService_DeleteUserState_FullMethodName       = "/chatbot.UserStateService/DeleteUserState"
	UserStateService_GetUserState_FullMethodName          = "/chatbot.UserStateService/GetUserState"
	UserStateService_GetAllUserStates_FullMethodName      = "/chatbot.UserStateService/GetAllUserStates"
)

// UserStateServiceClient is the client API for UserStateService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// /// Serviços de Estado do Usuário /////
type UserStateServiceClient interface {
	InsertUpdateUserState(ctx context.Context, in *UserState, opts ...grpc.CallOption) (*RequestStatus, error)
	DeleteUserState(ctx context.Context, in *ChatID, opts ...grpc.CallOption) (*RequestStatus, error)
	GetUserState(ctx context.Context, in *ChatID, opts ...grpc.CallOption) (*UserState, error)
	GetAllUserStates(ctx context.Context, in *Void, opts ...grpc.CallOption) (*UserStateList, error)
}

type userStateServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewUserStateServiceClient(cc grpc.ClientConnInterface) UserStateServiceClient {
	return &userStateServiceClient{cc}
}

func (c *userStateServiceClient) InsertUpdateUserState(ctx context.Context, in *UserState, opts ...grpc.CallOption) (*RequestStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestStatus)
	err := c.cc.Invoke(ctx, UserStateService_InsertUpdateUserState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userStateServiceClient) DeleteUserState(ctx context.Context, in *ChatID, opts ...grpc.CallOption) (*RequestStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestStatus)
	err := c.cc.Invoke(ctx, UserStateService_DeleteUserState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userStateServiceClient) GetUserState(ctx context.Context, in *ChatID, opts ...grpc.CallOption) (*UserState, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserState)
	err := c.cc.Invoke(ctx, UserStateService_GetUserState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userStateServiceClient) GetAllUserStates(ctx context.Context, in *Void, opts ...grpc.CallOption) (*UserStateList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserStateList)
	err := c.cc.Invoke(ctx, UserStateService_GetAllUserStates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserStateServiceServer is the server API for UserStateService service.
// All implementations must embed UnimplementedUserStateServiceServer
// for forward compatibility.
//
// /// Serviços de Estado do Usuário /////
type UserStateServiceServer interface {
	InsertUpdateUserState(context.Context, *UserState) (*RequestStatus, error)
	DeleteUserState(context.Context, *ChatID) (*RequestStatus, error)
	GetUserState(context.Context, *ChatID) (*UserState, error)
	GetAllUserStates(context.Context, *Void) (*UserStateList, error)
	mustEmbedUnimplementedUserStateServiceServer()
}

// UnimplementedUserStateServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedUserStateServiceServer struct{}

func (UnimplementedUserStateServiceServer) InsertUpdateUserState(context.Context, *UserState) (*RequestStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InsertUpdateUserState not implemented")
}
func (UnimplementedUserStateServiceServer) DeleteUserState(context.Context, *ChatID) (*RequestStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteUserState not implemented")
}
func (UnimplementedUserStateServiceServer) GetUserState(context.Context, *ChatID) (*UserState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserState not implemented")
}
func (UnimplementedUserStateServiceServer) GetAllUserStates(context.Context, *Void) (*UserStateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllUserStates not implemented")
}
func (UnimplementedUserStateServiceServer) mustEmbedUnimplementedUserStateServiceServer() {}
func (UnimplementedUserStateServiceServer) testEmbeddedByValue()                          {}

// UnsafeUserStateServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserStateServiceServer will
// result in compilation errors.
type UnsafeUserStateServiceServer interface {
	mustEmbedUnimplementedUserStateServiceServer()
}

func RegisterUserStateServiceServer(s grpc.ServiceRegistrar, srv UserStateServiceServer) {
	// If the following call pancis, it indicates UnimplementedUserStateServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&UserStateService_ServiceDesc, srv)
}

func _UserStateService_InsertUpdateUserState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserState)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserStateServiceServer).InsertUpdateUserState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserStateService_InsertUpdateUserState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserStateServiceServer).InsertUpdateUserState(ctx, req.(*UserState))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserStateService_DeleteUserState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserStateServiceServer).DeleteUserState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserStateService_DeleteUserState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserStateServiceServer).DeleteUserState(ctx, req.(*ChatID))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserStateService_GetUserState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChatID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserStateServiceServer).GetUserState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserStateService_GetUserState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserStateServiceServer).GetUserState(ctx, req.(*ChatID))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserStateService_GetAllUserStates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserStateServiceServer).GetAllUserStates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserStateService_GetAllUserStates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserStateServiceServer).GetAllUserStates(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

// UserStateService_ServiceDesc is the grpc.ServiceDesc for UserStateService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserStateService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatbot.UserStateService",
	HandlerType: (*UserStateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InsertUpdateUserState",
			Handler:    _UserStateService_InsertUpdateUserState_Handler,
		},
		{
			MethodName: "DeleteUserState",
			Handler:    _UserStateService_DeleteUserState_Handler,
		},
		{
			MethodName: "GetUserState",
			Handler:    _UserStateService_GetUserState_Handler,
		},
		{
			MethodName: "GetAllUserStates",
			Handler:    _UserStateService_GetAllUserStates_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "router.proto",
}

const (
	SendMessage_SendMessage_FullMethodName = "/chatbot.SendMessage/SendMessage"
)

// SendMessageClient is the client API for SendMessage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// /// Serviços de Mensagens /////
type SendMessageClient interface {
	SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*RequestStatus, error)
}

type sendMessageClient struct {
	cc grpc.ClientConnInterface
}

func NewSendMessageClient(cc grpc.ClientConnInterface) SendMessageClient {
	return &sendMessageClient{cc}
}

func (c *sendMessageClient) SendMessage(ctx context.Context, in *Message, opts ...grpc.CallOption) (*RequestStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestStatus)
	err := c.cc.Invoke(ctx, SendMessage_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SendMessageServer is the server API for SendMessage service.
// All implementations must embed UnimplementedSendMessageServer
// for forward compatibility.
//
// /// Serviços de Mensagens /////
type SendMessageServer interface {
	SendMessage(context.Context, *Message) (*RequestStatus, error)
	mustEmbedUnimplementedSendMessageServer()
}

// UnimplementedSendMessageServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSendMessageServer struct{}

func (UnimplementedSendMessageServer) SendMessage(context.Context, *Message) (*RequestStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedSendMessageServer) mustEmbedUnimplementedSendMessageServer() {}
func (UnimplementedSendMessageServer) testEmbeddedByValue()                     {}

// UnsafeSendMessageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SendMessageServer will
// result in compilation errors.
type UnsafeSendMessageServer interface {
	mustEmbedUnimplementedSendMessageServer()
}

func RegisterSendMessageServer(s grpc.ServiceRegistrar, srv SendMessageServer) {
	// If the following call pancis, it indicates UnimplementedSendMessageServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SendMessage_ServiceDesc, srv)
}

func _SendMessage_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SendMessageServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SendMessage_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SendMessageServer).SendMessage(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

// SendMessage_ServiceDesc is the grpc.ServiceDesc for SendMessage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SendMessage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatbot.SendMessage",
	HandlerType: (*SendMessageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _SendMessage_SendMessage_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "router.proto",
}

const (
	Transfer_GetAllCampaigns_FullMethodName = "/chatbot.Transfer/GetAllCampaigns"
	Transfer_GetCampaignID_FullMethodName   = "/chatbot.Transfer/GetCampaignID"
	Transfer_TransferToHuman_FullMethodName = "/chatbot.Transfer/TransferToHuman"
	Transfer_TransferToMenu_FullMethodName  = "/chatbot.Transfer/TransferToMenu"
)

// TransferClient is the client API for Transfer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// /// Serviços de Transfer /////
type TransferClient interface {
	GetAllCampaigns(ctx context.Context, in *Void, opts ...grpc.CallOption) (*CampaignsList, error)
	GetCampaignID(ctx context.Context, in *CampaignName, opts ...grpc.CallOption) (*CampaignDetails, error)
	TransferToHuman(ctx context.Context, in *TransferToHumanRequest, opts ...grpc.CallOption) (*RequestStatus, error)
	TransferToMenu(ctx context.Context, in *TransferToMenuRequest, opts ...grpc.CallOption) (*RequestStatus, error)
}

type transferClient struct {
	cc grpc.ClientConnInterface
}

func NewTransferClient(cc grpc.ClientConnInterface) TransferClient {
	return &transferClient{cc}
}

func (c *transferClient) GetAllCampaigns(ctx context.Context, in *Void, opts ...grpc.CallOption) (*CampaignsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CampaignsList)
	err := c.cc.Invoke(ctx, Transfer_GetAllCampaigns_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferClient) GetCampaignID(ctx context.Context, in *CampaignName, opts ...grpc.CallOption) (*CampaignDetails, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CampaignDetails)
	err := c.cc.Invoke(ctx, Transfer_GetCampaignID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferClient) TransferToHuman(ctx context.Context, in *TransferToHumanRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestStatus)
	err := c.cc.Invoke(ctx, Transfer_TransferToHuman_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferClient) TransferToMenu(ctx context.Context, in *TransferToMenuRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestStatus)
	err := c.cc.Invoke(ctx, Transfer_TransferToMenu_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransferServer is the server API for Transfer service.
// All implementations must embed UnimplementedTransferServer
// for forward compatibility.
//
// /// Serviços de Transfer /////
type TransferServer interface {
	GetAllCampaigns(context.Context, *Void) (*CampaignsList, error)
	GetCampaignID(context.Context, *CampaignName) (*CampaignDetails, error)
	TransferToHuman(context.Context, *TransferToHumanRequest) (*RequestStatus, error)
	TransferToMenu(context.Context, *TransferToMenuRequest) (*RequestStatus, error)
	mustEmbedUnimplementedTransferServer()
}

// UnimplementedTransferServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTransferServer struct{}

func (UnimplementedTransferServer) GetAllCampaigns(context.Context, *Void) (*CampaignsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllCampaigns not implemented")
}
func (UnimplementedTransferServer) GetCampaignID(context.Context, *CampaignName) (*CampaignDetails, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCampaignID not implemented")
}
func (UnimplementedTransferServer) TransferToHuman(context.Context, *TransferToHumanRequest) (*RequestStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferToHuman not implemented")
}
func (UnimplementedTransferServer) TransferToMenu(context.Context, *TransferToMenuRequest) (*RequestStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferToMenu not implemented")
}
func (UnimplementedTransferServer) mustEmbedUnimplementedTransferServer() {}
func (UnimplementedTransferServer) testEmbeddedByValue()                  {}

// UnsafeTransferServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransferServer will
// result in compilation errors.
type UnsafeTransferServer interface {
	mustEmbedUnimplementedTransferServer()
}

func RegisterTransferServer(s grpc.ServiceRegistrar, srv TransferServer) {
	// If the following call pancis, it indicates UnimplementedTransferServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Transfer_ServiceDesc, srv)
}

func _Transfer_GetAllCampaigns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServer).GetAllCampaigns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Transfer_GetAllCampaigns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServer).GetAllCampaigns(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transfer_GetCampaignID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CampaignName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServer).GetCampaignID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Transfer_GetCampaignID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServer).GetCampaignID(ctx, req.(*CampaignName))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transfer_TransferToHuman_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferToHumanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServer).TransferToHuman(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Transfer_TransferToHuman_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServer).TransferToHuman(ctx, req.(*TransferToHumanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Transfer_TransferToMenu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransferToMenuRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServer).TransferToMenu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Transfer_TransferToMenu_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServer).TransferToMenu(ctx, req.(*TransferToMenuRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Transfer_ServiceDesc is the grpc.ServiceDesc for Transfer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Transfer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatbot.Transfer",
	HandlerType: (*TransferServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllCampaigns",
			Handler:    _Transfer_GetAllCampaigns_Handler,
		},
		{
			MethodName: "GetCampaignID",
			Handler:    _Transfer_GetCampaignID_Handler,
		},
		{
			MethodName: "TransferToHuman",
			Handler:    _Transfer_TransferToHuman_Handler,
		},
		{
			MethodName: "TransferToMenu",
			Handler:    _Transfer_TransferToMenu_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "router.proto",
}

const (
	EndChat_GetAllTabulations_FullMethodName = "/chatbot.EndChat/GetAllTabulations"
	EndChat_GetTabulationID_FullMethodName   = "/chatbot.EndChat/GetTabulationID"
	EndChat_EndChat_FullMethodName           = "/chatbot.EndChat/EndChat"
)

// EndChatClient is the client API for EndChat service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// /// Serviços de EndChat /////
type EndChatClient interface {
	GetAllTabulations(ctx context.Context, in *Void, opts ...grpc.CallOption) (*TabulationsList, error)
	GetTabulationID(ctx context.Context, in *TabulationName, opts ...grpc.CallOption) (*TabulationDetails, error)
	EndChat(ctx context.Context, in *EndChatRequest, opts ...grpc.CallOption) (*RequestStatus, error)
}

type endChatClient struct {
	cc grpc.ClientConnInterface
}

func NewEndChatClient(cc grpc.ClientConnInterface) EndChatClient {
	return &endChatClient{cc}
}

func (c *endChatClient) GetAllTabulations(ctx context.Context, in *Void, opts ...grpc.CallOption) (*TabulationsList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TabulationsList)
	err := c.cc.Invoke(ctx, EndChat_GetAllTabulations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endChatClient) GetTabulationID(ctx context.Context, in *TabulationName, opts ...grpc.CallOption) (*TabulationDetails, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TabulationDetails)
	err := c.cc.Invoke(ctx, EndChat_GetTabulationID_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *endChatClient) EndChat(ctx context.Context, in *EndChatRequest, opts ...grpc.CallOption) (*RequestStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestStatus)
	err := c.cc.Invoke(ctx, EndChat_EndChat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EndChatServer is the server API for EndChat service.
// All implementations must embed UnimplementedEndChatServer
// for forward compatibility.
//
// /// Serviços de EndChat /////
type EndChatServer interface {
	GetAllTabulations(context.Context, *Void) (*TabulationsList, error)
	GetTabulationID(context.Context, *TabulationName) (*TabulationDetails, error)
	EndChat(context.Context, *EndChatRequest) (*RequestStatus, error)
	mustEmbedUnimplementedEndChatServer()
}

// UnimplementedEndChatServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEndChatServer struct{}

func (UnimplementedEndChatServer) GetAllTabulations(context.Context, *Void) (*TabulationsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAllTabulations not implemented")
}
func (UnimplementedEndChatServer) GetTabulationID(context.Context, *TabulationName) (*TabulationDetails, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTabulationID not implemented")
}
func (UnimplementedEndChatServer) EndChat(context.Context, *EndChatRequest) (*RequestStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndChat not implemented")
}
func (UnimplementedEndChatServer) mustEmbedUnimplementedEndChatServer() {}
func (UnimplementedEndChatServer) testEmbeddedByValue()                 {}

// UnsafeEndChatServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EndChatServer will
// result in compilation errors.
type UnsafeEndChatServer interface {
	mustEmbedUnimplementedEndChatServer()
}

func RegisterEndChatServer(s grpc.ServiceRegistrar, srv EndChatServer) {
	// If the following call pancis, it indicates UnimplementedEndChatServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EndChat_ServiceDesc, srv)
}

func _EndChat_GetAllTabulations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndChatServer).GetAllTabulations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EndChat_GetAllTabulations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndChatServer).GetAllTabulations(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _EndChat_GetTabulationID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TabulationName)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndChatServer).GetTabulationID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EndChat_GetTabulationID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndChatServer).GetTabulationID(ctx, req.(*TabulationName))
	}
	return interceptor(ctx, in, info, handler)
}

func _EndChat_EndChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndChatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EndChatServer).EndChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EndChat_EndChat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EndChatServer).EndChat(ctx, req.(*EndChatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EndChat_ServiceDesc is the grpc.ServiceDesc for EndChat service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EndChat_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "chatbot.EndChat",
	HandlerType: (*EndChatServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAllTabulations",
			Handler:    _EndChat_GetAllTabulations_Handler,
		},
		{
			MethodName: "GetTabulationID",
			Handler:    _EndChat_GetTabulationID_Handler,
		},
		{
			MethodName: "EndChat",
			Handler:    _EndChat_EndChat_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "router.proto",
}
